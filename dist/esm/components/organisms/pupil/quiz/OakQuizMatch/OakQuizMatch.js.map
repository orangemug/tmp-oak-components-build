{"version":3,"file":"OakQuizMatch.js","sources":["../../../../../../../src/components/organisms/pupil/quiz/OakQuizMatch/OakQuizMatch.tsx"],"sourcesContent":["import React, { ReactNode, useEffect, useRef, useState } from \"react\";\nimport {\n  closestCenter,\n  KeyboardSensor,\n  useSensor,\n  useSensors,\n  DragEndEvent,\n  DragOverlay,\n  DragStartEvent,\n  Announcements,\n  MouseSensor,\n  TouchSensor,\n  useDraggable,\n  useDroppable,\n} from \"@dnd-kit/core\";\nimport { sortableKeyboardCoordinates } from \"@dnd-kit/sortable\";\n\nimport { InternalDroppableHoldingPen } from \"@/components/organisms/pupil/quiz/InternalDroppableHoldingPen\";\nimport { OakFlex } from \"@/components/atoms\";\nimport {\n  OakDragAndDropInstructions,\n  OakDraggable,\n  OakDroppable,\n} from \"@/components/molecules\";\nimport { usePrefersReducedMotion } from \"@/animation/usePrefersReducedMotion\";\nimport { InternalDndContext } from \"@/components/atoms/InternalDndContext/InternalDndContext\";\nimport { InternalClientPortal } from \"@/components/atoms/InternalClientPortal\";\n\ntype DraggableId = string;\ntype DroppableId = string;\ntype DraggableItem = {\n  id: DraggableId;\n  label: ReactNode;\n};\ntype DroppableItem = {\n  id: DroppableId;\n  label: ReactNode;\n};\ntype Matches = Record<DroppableId, DraggableItem>;\n\nexport type OakQuizMatchProps = {\n  /**\n   * The initial options\n   *\n   * these are the items that can be dragged into a slot to form a match\n   *\n   * this cannot be updated on subsequent renders\n   */\n  initialOptions: DraggableItem[];\n  /**\n   * The initial slots\n   *\n   * these are the slots into which an option can be dropped to form a match\n   *\n   * this cannot be updated on subsequent renders\n   */\n  initialSlots: DroppableItem[];\n  /**\n   * Notify the consumer when matches have changed\n   */\n  onChange?: (matches: Matches) => void;\n  /**\n   * Highlight the droppable slots\n   */\n  isHighlighted?: boolean;\n};\n\nconst ConnectedDraggable = ({\n  id,\n  label,\n  isOver,\n}: DraggableItem & { isOver?: boolean }) => {\n  const { attributes, listeners, setNodeRef, isDragging } = useDraggable({\n    id,\n    data: { id, label },\n  });\n\n  return (\n    <OakDraggable\n      ref={setNodeRef}\n      isDisabled={isOver}\n      color=\"text-inverted\"\n      background=\"bg-btn-primary\"\n      iconColor=\"icon-main\"\n      {...attributes}\n      {...listeners}\n      role=\"option\"\n      aria-describedby={undefined}\n      aria-roledescription=\"draggable item\"\n      aria-pressed={undefined}\n      aria-selected={!!attributes[\"aria-pressed\"]}\n      style={{ opacity: isDragging ? 0 : 1 }}\n    >\n      {label}\n    </OakDraggable>\n  );\n};\n\nconst ConnectedDroppableHoldingPen = ({\n  children,\n}: {\n  children?: ReactNode;\n}) => {\n  const { setNodeRef, isOver } = useDroppable({\n    id: \"holding-pen\",\n    data: { label: \"holding pen\" },\n  });\n\n  return (\n    <InternalDroppableHoldingPen\n      ref={setNodeRef}\n      isOver={isOver}\n      aria-label=\"Available items\"\n      data-testid=\"holding-pen\"\n      role=\"listbox\"\n    >\n      {children}\n    </InternalDroppableHoldingPen>\n  );\n};\n\nconst ConnectedDroppable = ({\n  id,\n  label,\n  match,\n  isHighlighted,\n}: DroppableItem & { match?: DraggableItem; isHighlighted?: boolean }) => {\n  const { setNodeRef, isOver, active } = useDroppable({\n    id,\n    data: { id, label },\n  });\n\n  return (\n    <OakDroppable\n      isOver={isOver}\n      isDisabled={!active}\n      ref={setNodeRef}\n      id={id}\n      labelSlot={label}\n      data-testid=\"slot\"\n      isHighlighted={isHighlighted}\n    >\n      {match && <ConnectedDraggable {...match} isOver={isOver} />}\n    </OakDroppable>\n  );\n};\n\n/**\n * A list of draggable items with matching slots to drop them into.\n *\n * Keyboard navigation is supported with the `tab`, `space` and `arrow` keys\n */\nexport const OakQuizMatch = ({\n  initialOptions,\n  initialSlots,\n  isHighlighted,\n  onChange,\n}: OakQuizMatchProps) => {\n  const [matches, setMatches] = useState<Matches>({});\n  const draggables = useRef(initialOptions.slice()).current;\n  const [shuffledDraggables, setShuffledDraggables] =\n    useState<DraggableItem[]>(draggables);\n  const droppables = useRef(initialSlots).current;\n  const [activeId, setActiveId] = useState<DraggableId | null>(null);\n  const activeDraggable = draggables.find((item) => item.id === activeId);\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const sensors = useSensors(\n    useSensor(MouseSensor),\n    useSensor(TouchSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n      scrollBehavior: prefersReducedMotion ? \"instant\" : \"smooth\",\n    }),\n  );\n\n  useEffect(() => {\n    const matchedDraggableIds = Object.values(matches).map((item) => item.id);\n\n    const unmatchedDraggables = draggables.filter(\n      (draggable) => !matchedDraggableIds.includes(draggable.id),\n    );\n    setShuffledDraggables(unmatchedDraggables.sort(() => Math.random() - 0.5));\n  }, [draggables, matches]);\n\n  return (\n    <>\n      <OakDragAndDropInstructions $mb=\"space-between-m2\" />\n      <InternalDndContext\n        sensors={sensors}\n        collisionDetection={closestCenter}\n        onDragEnd={handleDragEnd}\n        onDragStart={handleDragStart}\n        accessibility={{ announcements }}\n      >\n        <ConnectedDroppableHoldingPen>\n          {shuffledDraggables.map((item) => (\n            <ConnectedDraggable key={item.id} {...item} />\n          ))}\n        </ConnectedDroppableHoldingPen>\n        <OakFlex\n          $gap=\"space-between-s\"\n          $flexDirection=\"column\"\n          aria-label=\"Matched items\"\n          role=\"listbox\"\n        >\n          {droppables.map((droppable) => (\n            <ConnectedDroppable\n              key={droppable.id}\n              {...droppable}\n              isHighlighted={isHighlighted}\n              match={matches[droppable.id]}\n            />\n          ))}\n        </OakFlex>\n        <InternalClientPortal show={true}>\n          <DragOverlay dropAnimation={prefersReducedMotion ? null : undefined}>\n            {activeDraggable && (\n              <OakDraggable isDragging>{activeDraggable.label}</OakDraggable>\n            )}\n          </DragOverlay>\n        </InternalClientPortal>\n      </InternalDndContext>\n    </>\n  );\n\n  function handleDragStart(event: DragStartEvent) {\n    const { active } = event;\n    setActiveId(active.id.toString());\n  }\n\n  function handleDragEnd(event: DragEndEvent) {\n    const { active, over } = event;\n\n    if (over) {\n      setMatches((matches) => {\n        // Remove the draggable from its current slot\n        const entries = Object.entries(matches).filter(\n          ([, draggable]) => draggable?.id !== active.id,\n        );\n        const newMatches = Object.fromEntries(entries);\n\n        if (over.id !== \"holding-pen\") {\n          // We've dropped the draggable into a slot so add it to the new slot\n          newMatches[over.id] = active.data.current as DraggableItem;\n        }\n\n        onChange?.(newMatches);\n\n        return newMatches;\n      });\n    }\n\n    setActiveId(null);\n  }\n};\n\nconst announcements: Announcements = {\n  onDragStart() {\n    return undefined;\n  },\n  onDragOver({ active, over }) {\n    if (over?.data.current && active.data?.current) {\n      return `Item ${active.data.current.label} is over ${over.data.current.label}`;\n    }\n  },\n  onDragEnd({ active, over }) {\n    if (over?.data.current && active.data?.current) {\n      return `Item ${active.data.current.label} was dropped onto ${over.data.current.label}`;\n    }\n  },\n  onDragCancel({ active }) {\n    if (active.data?.current) {\n      return `Dragging was cancelled. Item ${active.data.current.label} was dropped.`;\n    }\n  },\n};\n"],"names":["ConnectedDraggable","id","label","isOver","attributes","listeners","setNodeRef","isDragging","useDraggable","data","React","createElement","OakDraggable","ref","isDisabled","color","background","iconColor","role","undefined","style","opacity","ConnectedDroppableHoldingPen","children","useDroppable","InternalDroppableHoldingPen","ConnectedDroppable","match","isHighlighted","active","OakDroppable","labelSlot","OakQuizMatch","initialOptions","initialSlots","onChange","matches","setMatches","useState","draggables","useRef","slice","current","shuffledDraggables","setShuffledDraggables","droppables","activeId","setActiveId","activeDraggable","find","item","prefersReducedMotion","usePrefersReducedMotion","sensors","useSensors","useSensor","MouseSensor","TouchSensor","KeyboardSensor","coordinateGetter","sortableKeyboardCoordinates","scrollBehavior","useEffect","matchedDraggableIds","Object","values","map","unmatchedDraggables","filter","draggable","includes","sort","Math","random","Fragment","OakDragAndDropInstructions","$mb","InternalDndContext","collisionDetection","closestCenter","onDragEnd","event","over","entries","newMatches","fromEntries","onDragStart","toString","accessibility","announcements","key","OakFlex","$flexDirection","droppable","InternalClientPortal","show","DragOverlay","dropAnimation","onDragOver","onDragCancel"],"mappings":"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"}